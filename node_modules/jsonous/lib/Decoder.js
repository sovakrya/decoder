"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.dict = exports.keyValuePairs = exports.oneOf = exports.nullable = exports.maybe = exports.at = exports.field = exports.array = exports.dateJSON = exports.dateISO = exports.date = exports.boolean = exports.number = exports.string = exports.fail = exports.succeed = void 0;
var date_fns_1 = require("date-fns");
var maybeasy_1 = require("maybeasy");
var resulty_1 = require("resulty");
var ErrorStringify_1 = require("./ErrorStringify");
var Decoder = (function () {
    function Decoder(fn) {
        var _this = this;
        this.fn = fn;
        this.map = function (f) {
            return new Decoder(function (value) {
                return _this.fn(value).map(f);
            });
        };
        this.and = this.map;
        this.andThen = function (f) {
            return new Decoder(function (value) {
                return _this.fn(value).andThen(function (v) { return f(v).decodeAny(value); });
            });
        };
        this.assign = function (k, other) {
            return _this.andThen(function (a) {
                var decoder = other instanceof Decoder ? other : other(a);
                return decoder.map(function (b) {
                    var _a;
                    return (__assign(__assign({}, Object(a)), (_a = {}, _a[k.toString()] = b, _a)));
                });
            });
        };
        this.do = function (fn) {
            return _this.map(function (v) {
                fn(v);
                return v;
            });
        };
        this.mapError = function (f) {
            return new Decoder(function (value) {
                return _this.fn(value).mapError(f);
            });
        };
        this.orElse = function (f) {
            return new Decoder(function (value) {
                return _this.fn(value).orElse(function (e) { return f(e).decodeAny(value); });
            });
        };
        this.elseDo = function (f) {
            return new Decoder(function (value) {
                return _this.fn(value).elseDo(f);
            });
        };
        this.decodeAny = function (value) { return _this.fn(value); };
        this.decodeJson = function (json) {
            try {
                var value = JSON.parse(json);
                return _this.decodeAny(value);
            }
            catch (e) {
                return (0, resulty_1.err)(String(e));
            }
        };
        this.toAnyFn = function () {
            return function (value) { return _this.decodeAny(value); };
        };
        this.toJsonFn = function () {
            return function (json) { return _this.decodeJson(json); };
        };
    }
    return Decoder;
}());
exports.default = Decoder;
var succeed = function (value) { return new Decoder(function (_) { return (0, resulty_1.ok)(value); }); };
exports.succeed = succeed;
var fail = function (message) { return new Decoder(function (_) { return (0, resulty_1.err)(message); }); };
exports.fail = fail;
exports.string = new Decoder(function (value) {
    if (typeof value !== 'string') {
        var stringified = (0, ErrorStringify_1.stringify)(value);
        var errorMsg = "I expected to find a string but instead I found ".concat(stringified);
        return (0, resulty_1.err)(errorMsg);
    }
    return (0, resulty_1.ok)(value);
});
exports.number = new Decoder(function (value) {
    if (typeof value !== 'number') {
        var errorMsg = "I expected to find a number but instead I found ".concat((0, ErrorStringify_1.stringify)(value));
        return (0, resulty_1.err)(errorMsg);
    }
    return (0, resulty_1.ok)(value);
});
exports.boolean = new Decoder(function (value) {
    if (typeof value !== 'boolean') {
        var errorMsg = "I expected to find a boolean but instead found ".concat((0, ErrorStringify_1.stringify)(value));
        return (0, resulty_1.err)(errorMsg);
    }
    return (0, resulty_1.ok)(value);
});
exports.date = new Decoder(function (value) {
    var errMsg = function (v) { return "I expected a date but instead I found ".concat((0, ErrorStringify_1.stringify)(v)); };
    return (0, resulty_1.ok)(value)
        .andThen(function (s) { return exports.string.map(function (v) { return new Date(v); }).decodeAny(s); })
        .orElse(function (n) { return exports.number.map(function (v) { return new Date(v); }).decodeAny(n); })
        .andThen(function (d) { return (isNaN(d.getTime()) ? (0, resulty_1.err)(value) : (0, resulty_1.ok)(d)); })
        .mapError(function () { return errMsg(value); });
});
exports.dateISO = new Decoder(function (value) {
    return (0, resulty_1.ok)(value)
        .andThen(function (v) { return exports.string.decodeAny(v); })
        .map(date_fns_1.parseISO)
        .andThen(function (d) {
        return (0, date_fns_1.isValid)(d) ? (0, resulty_1.ok)(d) : (0, resulty_1.err)("I expected an ISO date but instead I found ".concat((0, ErrorStringify_1.stringify)(value)));
    });
});
exports.dateJSON = new Decoder(function (value) {
    return (0, resulty_1.ok)(value)
        .andThen(function (v) { return exports.string.decodeAny(v); })
        .map(date_fns_1.parseJSON)
        .andThen(function (d) {
        return (0, date_fns_1.isValid)(d) ? (0, resulty_1.ok)(d) : (0, resulty_1.err)("I expected an JSON date but instead I found ".concat((0, ErrorStringify_1.stringify)(value)));
    });
});
var array = function (decoder) {
    return new Decoder(function (value) {
        if (!(value instanceof Array)) {
            var errorMsg = "I expected an array but instead I found ".concat((0, ErrorStringify_1.stringify)(value));
            return (0, resulty_1.err)(errorMsg);
        }
        var result = (0, resulty_1.ok)([]);
        var _loop_1 = function (idx) {
            result = decoder
                .decodeAny(value[idx])
                .andThen(function (v) { return result.map(function (vs) { return vs.concat([v]); }); })
                .mapError(function (e) { return "".concat(e, ":\nerror found in an array at [").concat(idx, "]"); });
            if (failed(result)) {
                return "break";
            }
        };
        for (var idx = 0; idx < value.length; idx++) {
            var state_1 = _loop_1(idx);
            if (state_1 === "break")
                break;
        }
        return result;
    });
};
exports.array = array;
var field = function (name, decoder) {
    return new Decoder(function (value) {
        var errorMsg = function () {
            var stringified = (0, ErrorStringify_1.stringify)(value);
            var msg = "I expected to find an object with key '".concat(name, "' but instead I found ").concat(stringified);
            return (0, resulty_1.err)(msg);
        };
        if (value == null) {
            return errorMsg();
        }
        if (!value.hasOwnProperty(name)) {
            return errorMsg();
        }
        var v = value[name];
        return decoder.decodeAny(v).mapError(function (e) { return "".concat(e, ":\noccurred in a field named '").concat(name, "'"); });
    });
};
exports.field = field;
var at = function (path, decoder) {
    return new Decoder(function (value) {
        if (value == null) {
            return (0, resulty_1.err)("I found an error. Could not apply 'at' path to an undefined or null value.");
        }
        var val = value;
        var idx = 0;
        while (idx < path.length) {
            val = val[path[idx]];
            if (val === undefined) {
                var pathStr = (0, ErrorStringify_1.stringify)(path.slice(0, idx + 1));
                var valueStr = (0, ErrorStringify_1.stringify)(value);
                return (0, resulty_1.err)("I found an error in the 'at' path. I could not find path '".concat(pathStr, "' in ").concat(valueStr));
            }
            idx += 1;
        }
        return decoder.decodeAny(val);
    });
};
exports.at = at;
var maybe = function (decoder) {
    return new Decoder(function (value) {
        return decoder.decodeAny(value).cata({
            Err: function (e) { return (0, resulty_1.ok)((0, maybeasy_1.nothing)()); },
            Ok: function (v) { return (0, resulty_1.ok)((0, maybeasy_1.just)(v)); },
        });
    });
};
exports.maybe = maybe;
var nullable = function (decoder) {
    return new Decoder(function (value) {
        if (value == null) {
            return (0, resulty_1.ok)((0, maybeasy_1.nothing)());
        }
        return decoder.decodeAny(value).map(maybeasy_1.just);
    });
};
exports.nullable = nullable;
var oneOf = function (decoders) {
    return new Decoder(function (value) {
        if (decoders.length === 0) {
            return (0, resulty_1.err)('No decoders specified.');
        }
        var result = decoders.reduce(function (memo, decoder) {
            return memo.orElse(function (err1) { return decoder.decodeAny(value).mapError(function (err2) { return "".concat(err1, "\n").concat(err2); }); });
        }, (0, resulty_1.err)(''));
        return result.mapError(function (m) { return "I found the following problems:\n".concat(m); });
    });
};
exports.oneOf = oneOf;
var keyValuePairs = function (decoder) {
    return new Decoder(function (value) {
        if (typeof value !== 'object' || value === null || value instanceof Array) {
            return (0, resulty_1.err)("Expected to find an object and instead found '".concat((0, ErrorStringify_1.stringify)(value), "'"));
        }
        return Object.keys(value).reduce(function (memo, key) {
            return memo.andThen(function (pairs) {
                return decoder
                    .decodeAny(value[key])
                    .mapError(function (err) { return "Key '".concat(key, "' failed to decode: ").concat(err); })
                    .map(function (v) { return pairs.concat([[key, v]]); });
            });
        }, (0, resulty_1.ok)([]));
    });
};
exports.keyValuePairs = keyValuePairs;
var dict = function (decoder) {
    return (0, exports.keyValuePairs)(decoder).map(function (pairs) {
        return pairs.reduce(function (memo, _a) {
            var key = _a[0], value = _a[1];
            memo.set(key, value);
            return memo;
        }, new Map());
    });
};
exports.dict = dict;
function failed(r) {
    return r.cata({
        Err: function (_) { return true; },
        Ok: function (_) { return false; },
    });
}
//# sourceMappingURL=Decoder.js.map